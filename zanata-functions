#!/bin/bash
### NAME
###     zanata-functions
###
### SYNOPSIS
###     zanata-functions [help|exit-status-help]
### 
### DESCRIPTION
###     This script is basically for source (include) from other script.
### 
: ${WORK_ROOT:=/tmp/zanata}
: ${REPO_LOCAL_DIR:=/tmp/maven-central-release-repo}
: ${ZANATA_GIT_URL_PREFIX:=git@github.com:zanata}

### FUNCTIONS
function zanata_functions_get_path(){
    shopt -s extdebug
    declare -F zanata_functions_get_path | sed -e 's|^[^/]*||'
    shopt -u extdebug
}

function zanata_script_help_header(){
    local script=$1
    [ -z "$script" ] && script=$0
    sed -n -e '/^###/ {s|^###||p}' $script |  sed -e '/^\s*EXIT_STATUS/,$d'
}

function zanata_script_exit_status_help(){
    sed -n -e '/^###/ {s|^###||p}' $(zanata_functions_get_path) | sed -e '0,/^\s*EXIT_STATUS/d'
}

function zanata_script_help(){
    zanata_script_help_header $1
    echo -e " EXIT_STATUS"
    zanata_script_exit_status_help
}
    
function echo_stderr(){
    echo "$@" > /dev/stderr
}

function get_git_url(){
    echo "${ZANATA_GIT_URL_PREFIX}/$1.git"
}

###     checkout_releasing_branch <module> 
###         checkout RELEASING_BRANCH, the branch that we recommend downstream to use.
function checkout_releasing_branch(){
    local module=$1
    local branch=$(get_releasing_branch $module)
    pushd ${WORK_ROOT}/${module} >/dev/null
    git fetch
    git checkout ${branch}
    popd >/dev/null
}

###     checkout_devel_branch <module> 
###         checkout DEVEL_BRANCH, the branch the branch for committing new features.
function checkout_devel_branch(){
    local module=$1
    local branch=$(get_devel_branch $module)
    pushd ${WORK_ROOT}/${module} >/dev/null
    git fetch
    git checkout ${branch}
    popd >/dev/null
}

###     detect_module_tag <module>
###         Print latest tag of module
###         
function detect_module_tag(){
    local module=$1
    ensure_repo ${module}

    pushd ${WORK_ROOT}/${module} >/dev/null
    checkout_releasing_branch ${module} 1>/dev/stderr

    git fetch --tags 1>/dev/stderr
    local latestTag=$(git describe --abbrev=0 --tags)
    popd >/dev/null

    echo_stderr "### detect_module_version: ${module}: Latest tag: $latestTag"
    echo "${latestTag}"
}

###     detect_module_version <module>
###         Print latest tagged module version.
###         
function detect_module_version(){
    local module=$1
    local latestTag=$(detect_module_tag ${module})
    local version=$(sed -e 's/.*-\([^-]*\)/\1/' <<< ${latestTag})
    test -n "$version"
    exit_if_failed "$?" ${EXIT_FATAL_FAIL} "Failed to get version from ${module}"

    echo_stderr "### detect_module_version: ${module}: Version: $version"
    echo "$version"
}

###     does_branch_exist <module> <branch>
function does_branch_exist(){
    local module=$1
    local branch=$2

    if [ ! -d "${WORK_ROOT}/${module}" ];then
	echo_stderr "[ERROR] ${WORK_ROOT}/${module} does not exist"
	exit ${EXIT_FATAL_MISSING_DEPENDENCY}
    fi

    pushd ${WORK_ROOT}/${module} >/dev/null
    echo_stderr -n "### Does ${module} has branch ${branch}?..."

    if git rev-parse --verify ${branch} &>/dev/null;then
	echo_stderr "yes" 
	return 0
    else
	echo_stderr "no"
	return ${EXIT_RETURN_FALSE}
    fi
    popd >/dev/null
}

###     ensure_repo_generic <parentDir> <module> [git_repo_url]
###         Ensure repo is at <parentDir>/<module>
function ensure_repo_generic(){
    local parentDir=$1
    local module=$2
    local git_repo_url=$3
    echo_stderr "### Ensure the repo $module is at ${parentDir}/${module}"
    if [ -z "$git_repo_url" ];then
	git_repo_url=$(get_git_url ${module})
    fi
    if [ ! -d ${parentDir} ];then
	mkdir -p ${parentDir}
    fi
    pushd ${parentDir} >/dev/null
    if [ ! -d ${module} ];then
	git clone "${git_repo_url}"
        if [ $? -ne 0 ];then
	    echo_stderr "[ERROR] Failed to clone ${git_repo_url}"
	    exit ${EXIT_FATAL_MISSING_DEPENDENCY}
        fi
    fi
    popd >/dev/null
}

###     ensure_repo <module> [git_repo_url]
###         Ensure repo is at $WORK_ROOT/<module>
function ensure_repo(){
    ensure_repo_generic "$WORK_ROOT" "$1" "$2"
}

###     ensure_devel_repo <module> [git_repo_url]
###         Ensure repo is at $DEVEL_ROOT/<module>
function ensure_devel_repo(){
    ensure_repo_generic "$DEVEL_ROOT" "$1" "$2"
}

###     exit_if_failed <var> <exitStatus> <exitMsg>
function exit_if_failed(){
    if [ $1 -ne 0 ];then
	local exitStatus=$2
	EXIT_MSG="$3"
	exit $exitStatus
    fi
}

###     exit_print_error
###         Print error message just before exit
###         Environment:
###             EXIT_MSG: Error message to print.
###
EXIT_MSG=
function exit_print_error(){
    local exitStatus=$?
    case $exitStatus in
	${EXIT_OK} )
	    echo_stderr "### Done ${EXIT_MSG}"
	    ;;
	${EXIT_FATAL_INVALID_OPTIONS} )
	    zanata_script_help $0
	    echo_stderr "### [FATAL] Invalid Options: ${EXIT_MSG}"
	    ;;
	${EXIT_FATAL_MISSING_DEPENDENCIES} )
	    echo_stderr "### [FATAL] Missing dependencies: ${EXIT_MSG}"
	    ;;
	${EXIT_FATAL_UNKNOWN_MODULE} )
	    zanata_script_help $0
	    echo_stderr "### [FATAL] Unknown or Invalid module: ${EXIT_MSG}"
	    ;;
	${EXIT_FATAL_FAIL} )
	    echo_stderr "### [FATAL] Fail: ${EXIT_MSG}"
	    ;;
	* )
	    echo_stderr "### Unexpected Exit: ${EXIT_MSG}"
	    ;;
    esac
    exit ${exitStatus}
}


###     get_releasing_branch <module>
###         Determine RELEASING_BRANCH, the branch that we recommend downstream to use, 
###         and release process should mainly happen here.
###         It is:
###             'release' if that branch exists; otherwise
###             'integration/master' if that branch exists; otherwise
###              'master'.
function get_releasing_branch(){
    local module=$1
    if does_branch_exist ${module} origin/release ;then
        echo "release"
        return 0
    elif does_branch_exist ${module} origin/integration/master ;then
        echo "integration/master"
        return 0
    fi
    echo "master"
    return 0
}

###     get_devel_branch <module>
###         Determine DEVEL_BRANCH, the branch for committing new features. 
###         It is:
###             'integration/master' if that branch exists; otherwise
###             'master'.
function get_devel_branch(){
    local module=$1
    if does_branch_exist ${module} origin/integration/master ;then
        echo "integration/master"
        return 0
    fi
    echo "master"
    return 0
}

###     get_module <commandName>
###         Determine module.
###         Print: <module or - for unknown>
###
function get_module(){
    case $1 in
	*jgettext)
	    echo "jgettext"
	    ;;
	*openprops)
	    echo "openprops"
	    ;;
	*parent)
	    echo "zanata-parent"
	    ;;
	*api)
	    echo "zanata-api"
	    ;;
	*common)
	    echo "zanata-common"
	    ;;
	*client)
	    echo "zanata-client"
	    ;;
	*server)
	    echo "zanata-server"
	    ;;
	*)
	    echo "-"
	    ;;
    esac
}

###     get_module_from_command <firstArg>
###         Determine module. or exit with EXIT_FATAL_UNKNOWN_MODULE
###         Print: <module> <isShift>
###             module: module name
###             isShift: 1 for need shift, 0 otherwise.
###
function get_module_from_command(){
    local firstArg=$1

    Module=$(get_module $0)
    if [ "x$Module" = "x-" ];then
	Module=$(get_module $firstArg)
	if [ "x$Module" = "x-" ];then
	    exit ${EXIT_FATAL_UNKNOWN_MODULE}
	else
	    echo "$Module 1"
	fi
    else
	echo "$Module 0"
    fi
}

###     print_status [-n] [-s] [-t <Stage>] [message]
###         Print the status message.
###         Options:
###             -n: Do not print end-of-line in the end.
###             -s: prepend separation line before message
###             -t <Stage>: Specify Stage
###         If -s is specified, it will pad separation line before message, like
###         "[Stage]============================== Start"
###         It will use following Environment variables
###             Stage: As stage inside []
###
ZnatNoEOL=0
function print_status(){
    local outputStr=
    local optionArray=()
    local optionN=0

    if [ $ZnatNoEOL -eq 0 ];then
	## Previous line already ended
	outputStr+="### [$Stage]"
    fi
    while [[ $1 == -* ]]; do
	case $1 in
	    -n )
		optionArray+=( -n )
		shift
		ZnatNoEOL=1
		optionN=1
		;;
	    -s )
		outputStr+="=============================="
		shift
		;;
	    -t )
		shift
		Stage=$1
		shift
		;;
        esac
    done

    local message="$1"
    outputStr+="$message"
    echo_stderr ${optionArray[@]} "$outputStr"

    if [ $optionN -eq 0 ];then
	ZnatNoEOL=0
    fi
}

###     time-stamp [DATE_FORMAT]
###         Use stamp like "2015-06-29-06:56:34-953717856", base on UTC
###         Default: '%F-%R-%N'
###
function time-stamp(){
    local DATE_FORMAT=$1
    if [ -z "$DATE_FORMAT" ];then
	DATE_FORMAT='%F-%R-%N'
    fi
    date -u +"$DATE_FORMAT"
}

###
### EXIT_STATUS
###     Success
###         EXIT_OK
declare EXIT_OK=0

###     Fatal should stop immediately.
###         EXIT_FATAL_UNSPECIFIED: Unspecified fatal error, 
###             usually indicate a bug in our scripts.
declare EXIT_FATAL_UNSPECIFIED=1

###         EXIT_FATAL_INVALID_OPTIONS: Wrong options were given
declare EXIT_FATAL_INVALID_OPTIONS=3

###         EXIT_FATAL_MISSING_DEPENDENCY: Cannot find dependency
declare EXIT_FATAL_MISSING_DEPENDENCY=4

###         EXIT_FATAL_UNKNOWN_MODULE: Invalid or unknown module name.
declare EXIT_FATAL_UNKNOWN_MODULE=5

###         EXIT_FATAL_FAIL: Script detected that a fatal error occurred.
declare EXIT_FATAL_FAIL=5

###     Error that need to stop before next step.
###         EXIT_ERROR_FAIL: Script detected that an error occurred.
declare EXIT_ERROR_FAIL=20

###     Return value, should not print error messages.
###         EXIT_RETURN_FALSE: Script should return false
declare EXIT_RETURN_FALSE=40

case $1 in
    help )
        zanata_script_help $0
        ;;
    exit-status-help )
        zanata_script_exit_status_help
        ;;
esac
